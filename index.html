<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>函数学习与 Logo 设计（活动一 + 活动二）</title>
  <style>
    :root{
      --bg:#f6f7fb;
      --panel:#ffffff;
      --ink:#111;
      --muted:#666;
      --grid:#e6e6e6;
      --axis:#000;
      --shadow: 0 8px 24px rgba(0,0,0,.08);
      --radius: 14px;
      --btn:#111;
      --btn2:#2b2b2b;
      --danger:#b00020;
      --ok:#0b7a2a;
      --warn:#a06100;
    }
    *{box-sizing:border-box;}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Arial, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
      background: var(--bg);
      color: var(--ink);
    }
    header{
      padding: 12px 18px 10px 18px;
      border-bottom: 1px solid #e9e9ee;
      background: #fff;
      position: sticky;
      top:0;
      z-index:10;
    }
    header .topline{
      display:flex;
      align-items:flex-start;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    header .title{ font-size: 18px; font-weight: 800; letter-spacing: .2px; }
    header .subtitle{ margin-top: 6px; font-size: 12px; color: var(--muted); line-height: 1.45; }

    .tabbar{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap: wrap;
      margin-top: 10px;
    }
    .tab{
      border: 1px solid #d8d8e2;
      background: #fff;
      color: var(--ink);
      padding: 8px 12px;
      border-radius: 999px;
      cursor:pointer;
      font-size: 13px;
      user-select:none;
    }
    .tab.active{
      border-color: rgba(0,0,0,.35);
      background: #111;
      color: #fff;
      font-weight: 700;
    }

    .page{
      display:none;
      padding: 14px;
    }
    .page.active{ display:block; }

    .wrap{
      display:flex;
      gap:14px;
      align-items: stretch;
      min-height: calc(100vh - 132px);
    }

    .left{
      flex: 0 0 70%;
      min-width: 560px;
      background: var(--panel);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px;
      display:flex;
      flex-direction: column;
    }
    .canvasBar{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap:10px;
      padding: 6px 4px 10px 4px;
      flex-wrap: wrap;
    }
    .canvasBar .group{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .btn{
      appearance:none;
      border:none;
      background: var(--btn);
      color:#fff;
      border-radius: 10px;
      padding: 9px 12px;
      font-size: 13px;
      cursor:pointer;
      user-select:none;
    }
    .btn.secondary{ background: var(--btn2); }
    .btn.ghost{
      background: transparent;
      border: 1px solid #d8d8e2;
      color: var(--ink);
    }
    .btn.danger{ background: var(--danger); }
    .toggle{
      display:flex;
      align-items:center;
      gap:8px;
      font-size: 13px;
      color: var(--ink);
      user-select:none;
    }
    .toggle input{ transform: translateY(1px); }

    canvas.stage{
      width:100%;
      flex: 1 1 auto;
      min-height: 640px;
      border: 1px solid #ececf3;
      border-radius: 12px;
      background: #fff;
      display:block;
      touch-action: none;
    }

    .right{
      flex: 1 1 30%;
      min-width: 360px;
      background: var(--panel);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px;
      display:flex;
      flex-direction: column;
      gap: 10px;
      overflow:auto;
    }

    .hintBox{
      border: 1px dashed #d8d8e2;
      border-radius: 12px;
      padding: 10px 12px;
      background: #fcfcff;
    }
    .hintBox .hintTitle{ font-weight: 800; font-size: 13px; margin-bottom: 6px; }
    .hintBox .hintText{ font-size: 12px; color: var(--muted); line-height: 1.55; }

    .row{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap:10px;
      margin-top: 10px;
    }
    .row label{ font-size: 12px; color: var(--ink); min-width: 84px; }
    .row .val{ font-size: 12px; color: var(--muted); min-width: 60px; text-align:right; }
    .row .ctrl{ flex: 1 1 auto; display:flex; gap:8px; align-items:center; }
    input[type="range"]{ width: 100%; }
    input[type="number"]{
      width: 100%;
      padding: 8px 10px;
      border: 1px solid #dfe0ea;
      border-radius: 10px;
      font-size: 13px;
      outline:none;
    }
    .small{ font-size: 12px; color: var(--muted); }

    /* 活动二卡片样式（沿用） */
    .statusRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      font-size: 12px;
      margin-top: 8px;
    }
    .badge{
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid #e2e2ea;
      background: #fff;
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .badge.ok{ border-color: rgba(11,122,42,.35); color: var(--ok); }
    .badge.warn{ border-color: rgba(160,97,0,.35); color: var(--warn); }

    .topActions{ display:flex; gap:10px; flex-wrap: wrap; }

    .panelSectionTitle{ margin-top: 4px; font-size: 13px; font-weight: 800; }

    .cards{ display:flex; flex-direction: column; gap: 10px; }

    .card{
      border: 1px solid #e7e7ef;
      border-radius: 12px;
      padding: 10px;
      background: #fff;
    }
    .cardHeader{
      display:flex;
      align-items:flex-start;
      justify-content: space-between;
      gap:10px;
    }
    .cardTitle{ font-weight: 800; font-size: 13px; line-height: 1.35; }
    .expr{ font-size: 12px; color: var(--muted); margin-top: 4px; word-break: break-word; }

    .cardOps{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .miniBtn{
      border: 1px solid #d8d8e2;
      background: #fff;
      color: var(--ink);
      border-radius: 9px;
      padding: 6px 9px;
      font-size: 12px;
      cursor:pointer;
    }
    .miniBtn.danger{ border-color: rgba(176,0,32,.35); color: var(--danger); }
    .miniBtn.primary{ border-color: rgba(0,0,0,.25); font-weight: 700; }

    .domainGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top: 8px;
    }
    .domainGrid .field label{
      display:block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    .domainGrid .field .pair{
      display:flex;
      gap:8px;
      align-items:center;
    }

    .emptyTip{
      border: 1px dashed #d8d8e2;
      border-radius: 12px;
      padding: 10px;
      background:#fff;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.6;
    }

    .colorDot{
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display:inline-block;
      transform: translateY(1px);
      margin-right: 6px;
      border:1px solid rgba(0,0,0,.12);
    }

    @media (max-width: 1100px){
      .wrap{ flex-direction: column; }
      .left, .right{ flex: 1 1 auto; min-width: unset; }
      .left{ min-height: 55vh; }
      canvas.stage{ min-height: 55vh; }
    }
  </style>
</head>
<body>
<header>
  <div class="topline">
    <div>
      <div class="title">函数学习与 Logo 设计（活动一 + 活动二）</div>
      <div class="subtitle">
        活动一：观察 y=|x| 与 y=|x+a| 的左右平移关系。<br/>
        活动二：函数 Logo 设计工作台（可拖动曲线与端点裁剪定义域，可隐藏坐标系）。
      </div>
    </div>
  </div>

  <div class="tabbar">
    <button class="tab active" id="tabAct1">活动一：观察 |x+a|</button>
    <button class="tab" id="tabAct2">活动二：函数 Logo 设计工作台</button>
  </div>
</header>

<!-- 活动一 -->
<section class="page active" id="pageAct1">
  <div class="wrap">
    <section class="left">
      <div class="canvasBar">
        <div class="group">
          <button class="btn ghost" id="a1ResetViewBtn">重置视图</button>
          <button class="btn ghost" id="a1ToggleAxesBtn">隐藏坐标系</button>
          <label class="toggle">
            <input type="checkbox" id="a1GridToggle" checked />
            显示网格
          </label>
        </div>
        <div class="group small">
          视窗：x∈[<span id="a1vxMin">-10</span>, <span id="a1vxMax">10</span>]，
          y∈[<span id="a1vyMin">-10</span>, <span id="a1vyMax">10</span>]
        </div>
      </div>
      <canvas class="stage" id="a1Stage"></canvas>
    </section>

    <aside class="right">
      <div class="hintBox">
        <div class="hintTitle">观察任务</div>
        <div class="hintText">
          画布中灰色虚线为基准函数 y=|x|。拖动参数 a，观察 y=|x+a| 的图象如何变化，并用“左右平移”语言描述规律。<br/>
          提示：顶点位置与对称轴会随 a 改变。
        </div>
      </div>

      <div class="card">
        <div class="cardHeader">
          <div>
            <div class="cardTitle"><span class="colorDot" style="background:#1f77b4;"></span>y = |x + a|（可调）</div>
            <div class="expr" id="a1Expr">y = |x + 0|</div>
          </div>
        </div>

        <div class="row">
          <label>a：</label>
          <div class="ctrl">
            <input type="range" id="a1ASlider" min="-10" max="10" step="0.5" value="0">
            <input type="number" id="a1ANum" min="-10" max="10" step="0.5" value="0" style="max-width:110px;">
          </div>
          <span class="val" id="a1AVal">0</span>
        </div>

        <div class="row">
          <label>辅助：</label>
          <div class="ctrl">
            <input type="checkbox" id="a1ShowAxis" />
            <span class="small">显示对称轴 x = -a（竖直虚线）</span>
          </div>
          <span class="val"></span>
        </div>

      </div>
    </aside>
  </div>
</section>

<!-- 活动二 -->
<section class="page" id="pageAct2">
  <div class="wrap">
    <section class="left">
      <div class="canvasBar">
        <div class="group">
          <button class="btn ghost" id="a2ResetViewBtn">重置视图</button>
          <button class="btn danger" id="a2ClearAllBtn">清空画布</button>
          <button class="btn ghost" id="a2ToggleAxesBtn">隐藏坐标系</button>
          <label class="toggle">
            <input type="checkbox" id="a2GridToggle" checked />
            显示网格
          </label>
        </div>
        <div class="group small">
          视窗：x∈[<span id="a2vxMin">-30</span>, <span id="a2vxMax">30</span>]，
          y∈[<span id="a2vyMin">-30</span>, <span id="a2vyMax">30</span>]
        </div>
        <div class="group small">操作：拖动曲线=移动片段；拖动端点=改定义域</div>
      </div>
      <canvas class="stage" id="a2Stage"></canvas>
    </section>

    <aside class="right">
      <div class="hintBox">
        <div class="hintTitle">任务约束提示</div>
        <div class="hintText">
          至少 1 条 V 形函数 y=|x+a|；至少 1 条一次函数 y=kx+b；每条函数必须设置定义域；设计需能解释（平移/参数/定义域/对称或支撑或边界）。
        </div>
        <div class="statusRow">
          <span class="badge" id="a2StatusV">⚠️ 至少 1 条 V</span>
          <span class="badge" id="a2StatusL">⚠️ 至少 1 条直线</span>
        </div>
      </div>

      <div class="topActions">
        <button class="btn" id="a2AddVBtn">+ 添加 V 形函数</button>
        <button class="btn secondary" id="a2AddLBtn">+ 添加直线函数</button>
      </div>

      <div class="panelSectionTitle">构件列表</div>
      <div id="a2Cards" class="cards"></div>
      <div id="a2EmptyTip" class="emptyTip" style="display:none;">
        先点击上方按钮添加构件开始设计。提示：画布内可直接拖动曲线与端点。
      </div>
    </aside>
  </div>
</section>

<script>
document.addEventListener('DOMContentLoaded', () => {

  /** =========================
   *  顶部活动切换
   * ========================= */
  const tabAct1 = document.getElementById('tabAct1');
  const tabAct2 = document.getElementById('tabAct2');
  const pageAct1 = document.getElementById('pageAct1');
  const pageAct2 = document.getElementById('pageAct2');

  let a1Api = null;
  let a2Api = null;

  const setActiveTab = (which) => {
    if (which === 1){
      tabAct1.classList.add('active');
      tabAct2.classList.remove('active');
      pageAct1.classList.add('active');
      pageAct2.classList.remove('active');
      a1Api?.resize();
      a1Api?.draw();
    } else {
      tabAct2.classList.add('active');
      tabAct1.classList.remove('active');
      pageAct2.classList.add('active');
      pageAct1.classList.remove('active');
      a2Api?.resize();
      a2Api?.draw();
    }
  };

  tabAct1.addEventListener('click', () => setActiveTab(1));
  tabAct2.addEventListener('click', () => setActiveTab(2));

  /** =========================
   *  活动一：观察端
   * ========================= */
  function initActivity1(){
    const canvas = document.getElementById('a1Stage');
    const ctx = canvas.getContext('2d');

    const gridToggle = document.getElementById('a1GridToggle');
    const resetViewBtn = document.getElementById('a1ResetViewBtn');
    const toggleAxesBtn = document.getElementById('a1ToggleAxesBtn');

    const exprEl = document.getElementById('a1Expr');
    const aSlider = document.getElementById('a1ASlider');
    const aNum = document.getElementById('a1ANum');
    const aVal = document.getElementById('a1AVal');
    const showAxisCk = document.getElementById('a1ShowAxis');

    const vEls = {
      xMin: document.getElementById('a1vxMin'),
      xMax: document.getElementById('a1vxMax'),
      yMin: document.getElementById('a1vyMin'),
      yMax: document.getElementById('a1vyMax'),
    };

    const viewDefault = { xMin: -10, xMax: 10, yMin: -10, yMax: 10 };
    let view = { ...viewDefault };

    let showAxes = true;
    let a = 0;
    let showAxis = false;

    const setViewText = () => {
      vEls.xMin.textContent = view.xMin;
      vEls.xMax.textContent = view.xMax;
      vEls.yMin.textContent = view.yMin;
      vEls.yMax.textContent = view.yMax;
    };

    const getTransform = () => {
      const rect = canvas.getBoundingClientRect();
      const w = rect.width, h = rect.height;
      const xSpan = view.xMax - view.xMin;
      const ySpan = view.yMax - view.yMin;
      const scale = Math.min(w / xSpan, h / ySpan);
      const xC = (view.xMin + view.xMax) / 2;
      const yC = (view.yMin + view.yMax) / 2;
      return { w, h, scale, xC, yC };
    };

    const worldToScreen = (x, y) => {
      const { w, h, scale, xC, yC } = getTransform();
      const sx = (x - xC) * scale + w / 2;
      const sy = h / 2 - (y - yC) * scale;
      return { sx, sy };
    };

    // 合帧绘制
    let drawPending = false;
    const requestDraw = () => {
      if (drawPending) return;
      drawPending = true;
      requestAnimationFrame(() => {
        drawPending = false;
        draw();
      });
    };

    const resize = () => {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const cssW = Math.max(10, rect.width);
      const cssH = Math.max(10, rect.height);
      canvas.width = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      requestDraw();
    };

    const chooseNiceStep = (raw) => {
      const pow = Math.pow(10, Math.floor(Math.log10(raw)));
      const n = raw / pow;
      if (n < 1.5) return 1 * pow;
      if (n < 3.5) return 2 * pow;
      if (n < 7.5) return 5 * pow;
      return 10 * pow;
    };

    const drawGrid = () => {
      const { w, h, scale, xC, yC } = getTransform();
      const xHalf = (w/2) / scale;
      const yHalf = (h/2) / scale;
      const xVisMin = xC - xHalf, xVisMax = xC + xHalf;
      const yVisMin = yC - yHalf, yVisMax = yC + yHalf;

      ctx.save();
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim() || '#e6e6e6';
      ctx.lineWidth = 1;

      const step = chooseNiceStep(Math.max(view.xMax - view.xMin, view.yMax - view.yMin) / 12);

      for (let x = Math.ceil(xVisMin / step) * step; x <= xVisMax + 1e-9; x += step){
        const p1 = worldToScreen(x, yVisMin);
        const p2 = worldToScreen(x, yVisMax);
        ctx.beginPath();
        ctx.moveTo(p1.sx, p1.sy);
        ctx.lineTo(p2.sx, p2.sy);
        ctx.stroke();
      }
      for (let y = Math.ceil(yVisMin / step) * step; y <= yVisMax + 1e-9; y += step){
        const p1 = worldToScreen(xVisMin, y);
        const p2 = worldToScreen(xVisMax, y);
        ctx.beginPath();
        ctx.moveTo(p1.sx, p1.sy);
        ctx.lineTo(p2.sx, p2.sy);
        ctx.stroke();
      }
      ctx.restore();
    };

    const drawAxes = () => {
      const { w, h, scale, xC, yC } = getTransform();
      const xHalf = (w/2) / scale;
      const yHalf = (h/2) / scale;
      const xVisMin = xC - xHalf, xVisMax = xC + xHalf;
      const yVisMin = yC - yHalf, yVisMax = yC + yHalf;

      ctx.save();
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--axis').trim() || '#000';
      ctx.fillStyle = ctx.strokeStyle;
      ctx.lineWidth = 2;

      if (yVisMin <= 0 && yVisMax >= 0){
        const p1 = worldToScreen(xVisMin, 0);
        const p2 = worldToScreen(xVisMax, 0);
        ctx.beginPath();
        ctx.moveTo(p1.sx, p1.sy);
        ctx.lineTo(p2.sx, p2.sy);
        ctx.stroke();
      }

      if (xVisMin <= 0 && xVisMax >= 0){
        const p1 = worldToScreen(0, yVisMin);
        const p2 = worldToScreen(0, yVisMax);
        ctx.beginPath();
        ctx.moveTo(p1.sx, p1.sy);
        ctx.lineTo(p2.sx, p2.sy);
        ctx.stroke();
      }

      // x, y, O（要求）
      ctx.font = '13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Arial';
      ctx.textBaseline = 'middle';

      if (xVisMin <= 0 && xVisMax >= 0 && yVisMin <= 0 && yVisMax >= 0){
        const o = worldToScreen(0, 0);
        ctx.fillText('O', o.sx + 6, o.sy + 12);
      }
      if (yVisMin <= 0 && yVisMax >= 0){
        const p = worldToScreen(xVisMax, 0);
        ctx.fillText('x', p.sx - 14, p.sy + 18);
      }
      if (xVisMin <= 0 && xVisMax >= 0){
        const p = worldToScreen(0, yVisMax);
        ctx.fillText('y', p.sx + 12, p.sy + 10);
      }

      ctx.restore();
    };

    const drawCurve = (fn, style, dashed=false) => {
      const { w, h, scale, xC, yC } = getTransform();
      const xHalf = (w/2) / scale;
      const xVisMin = xC - xHalf, xVisMax = xC + xHalf;

      const samples = 800;
      const dx = (xVisMax - xVisMin) / samples;

      ctx.save();
      ctx.strokeStyle = style;
      ctx.lineWidth = 2;
      if (dashed) ctx.setLineDash([7,7]);
      ctx.beginPath();
      for (let i=0; i<=samples; i++){
        const x = xVisMin + i * dx;
        const y = fn(x);
        const p = worldToScreen(x, y);
        if (i===0) ctx.moveTo(p.sx, p.sy);
        else ctx.lineTo(p.sx, p.sy);
      }
      ctx.stroke();
      if (dashed) ctx.setLineDash([]);
      ctx.restore();
    };

    const drawSymAxis = () => {
      const x0 = -a;
      const { w, h, scale, xC, yC } = getTransform();
      const xHalf = (w/2) / scale;
      const yHalf = (h/2) / scale;
      const xVisMin = xC - xHalf, xVisMax = xC + xHalf;
      const yVisMin = yC - yHalf, yVisMax = yC + yHalf;
      if (x0 < xVisMin || x0 > xVisMax) return;

      const p1 = worldToScreen(x0, yVisMin);
      const p2 = worldToScreen(x0, yVisMax);

      ctx.save();
      ctx.strokeStyle = 'rgba(31,119,180,.45)';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.moveTo(p1.sx, p1.sy);
      ctx.lineTo(p2.sx, p2.sy);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    };

    // 新增：画布内“表达式标注（图象旁边）”——以图例形式呈现
    const getShiftExpr = () => {
      if (Math.abs(a) < 1e-12) return 'y = |x|';
      if (a > 0) return `y = |x + ${a}|`;
      return `y = |x - ${Math.abs(a)}|`;
    };

    const drawLegend = () => {
      const { w, h } = getTransform();

      const pad = 10;
      const boxW = 220;
      const boxH = 54;

      ctx.save();
      // 背景框
      ctx.fillStyle = 'rgba(255,255,255,.88)';
      ctx.strokeStyle = 'rgba(0,0,0,.10)';
      ctx.lineWidth = 1;
      // 简易圆角矩形
      const x = pad, y = pad, r = 10;
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + boxW - r, y);
      ctx.quadraticCurveTo(x + boxW, y, x + boxW, y + r);
      ctx.lineTo(x + boxW, y + boxH - r);
      ctx.quadraticCurveTo(x + boxW, y + boxH, x + boxW - r, y + boxH);
      ctx.lineTo(x + r, y + boxH);
      ctx.quadraticCurveTo(x, y + boxH, x, y + boxH - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // 字体
      ctx.font = '13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Arial';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#111';

      // 1) y=|x| 灰虚线
      const y1 = y + 18;
      ctx.save();
      ctx.strokeStyle = 'rgba(0,0,0,.35)';
      ctx.lineWidth = 2;
      ctx.setLineDash([7,7]);
      ctx.beginPath();
      ctx.moveTo(x + 12, y1);
      ctx.lineTo(x + 48, y1);
      ctx.stroke();
      ctx.restore();
      ctx.fillStyle = 'rgba(0,0,0,.75)';
      ctx.fillText('y = |x|', x + 56, y1);

      // 2) y=|x+a| 蓝实线（随 a 更新）
      const y2 = y + 38;
      ctx.save();
      ctx.strokeStyle = '#1f77b4';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(x + 12, y2);
      ctx.lineTo(x + 48, y2);
      ctx.stroke();
      ctx.restore();
      ctx.fillStyle = '#1f77b4';
      ctx.fillText(getShiftExpr(), x + 56, y2);

      ctx.restore();
    };

    const updateExpr = () => {
      const aStr = (a >= 0) ? `+ ${a}` : `- ${Math.abs(a)}`;
      exprEl.textContent = `y = |x ${aStr}|`;
      aVal.textContent = a.toString();
    };

    function draw(){
      const { w, h } = getTransform();
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0,0,w,h);

      if (gridToggle.checked) drawGrid();
      if (showAxes) drawAxes();

      // 基准 y=|x| 灰虚线
      drawCurve((x)=>Math.abs(x), 'rgba(0,0,0,.35)', true);

      // 变换 y=|x+a| 蓝实线
      drawCurve((x)=>Math.abs(x + a), '#1f77b4', false);

      if (showAxis) drawSymAxis();

      // 新增：表达式标注（图象旁边）
      drawLegend();
    }

    // 绑定 UI
    const commitA = (v) => {
      a = Math.max(-10, Math.min(10, v));
      a = Math.round(a * 2) / 2; // 0.5 步长对齐
      aSlider.value = a;
      aNum.value = a;
      updateExpr();
      requestDraw();
    };

    aSlider.addEventListener('input', () => commitA(parseFloat(aSlider.value)));
    aNum.addEventListener('change', () => commitA(parseFloat(aNum.value)));
    showAxisCk.addEventListener('change', () => { showAxis = showAxisCk.checked; requestDraw(); });

    resetViewBtn.addEventListener('click', () => {
      view = { ...viewDefault };
      setViewText();
      requestDraw();
    });

    toggleAxesBtn.addEventListener('click', () => {
      showAxes = !showAxes;
      toggleAxesBtn.textContent = showAxes ? '隐藏坐标系' : '显示坐标系';
      requestDraw();
    });

    gridToggle.addEventListener('change', () => requestDraw());

    const ro = new ResizeObserver(() => resize());
    ro.observe(canvas);
    window.addEventListener('resize', resize);

    setViewText();
    commitA(0);
    requestAnimationFrame(() => resize());

    return { resize, draw: requestDraw };
  }

  /** =========================
   *  活动二：生成性任务工作台
   *  （保持你确认“很好”的版本）
   * ========================= */
  function initActivity2(){
    const TYPE_V = 'V';
    const TYPE_L = 'L';

    const DOMAIN_MIN = -40;
    const DOMAIN_MAX =  40;
    const EPS = 0.1;
    const SNAP = 0.1;

    const snap = (v, step = SNAP) => Math.round(v / step) * step;
    const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
    const formatNum = (n) => {
      const v = Math.abs(n) < 1e-12 ? 0 : n;
      return (Math.round(v * 1000) / 1000).toString();
    };
    const hexToRgba = (hex, a) => {
      const h = hex.replace('#','').trim();
      const n = parseInt(h, 16);
      const r = (n >> 16) & 255;
      const g = (n >> 8) & 255;
      const b = n & 255;
      return `rgba(${r},${g},${b},${a})`;
    };

    const canvas = document.getElementById('a2Stage');
    const ctx = canvas.getContext('2d');

    const viewDefault = { xMin: -30, xMax: 30, yMin: -30, yMax: 30 };
    let view = { ...viewDefault };

    const vEls = {
      xMin: document.getElementById('a2vxMin'),
      xMax: document.getElementById('a2vxMax'),
      yMin: document.getElementById('a2vyMin'),
      yMax: document.getElementById('a2vyMax'),
    };
    const setViewText = () => {
      vEls.xMin.textContent = view.xMin;
      vEls.xMax.textContent = view.xMax;
      vEls.yMin.textContent = view.yMin;
      vEls.yMax.textContent = view.yMax;
    };

    let showAxes = true;
    const toggleAxesBtn = document.getElementById('a2ToggleAxesBtn');

    const getTransform = () => {
      const rect = canvas.getBoundingClientRect();
      const w = rect.width, h = rect.height;
      const xSpan = view.xMax - view.xMin;
      const ySpan = view.yMax - view.yMin;
      const scale = Math.min(w / xSpan, h / ySpan);
      const xC = (view.xMin + view.xMax) / 2;
      const yC = (view.yMin + view.yMax) / 2;
      return { w, h, scale, xC, yC };
    };

    const worldToScreen = (x, y) => {
      const { w, h, scale, xC, yC } = getTransform();
      const sx = (x - xC) * scale + w / 2;
      const sy = h / 2 - (y - yC) * scale;
      return { sx, sy };
    };

    const screenToWorld = (sx, sy) => {
      const { w, h, scale, xC, yC } = getTransform();
      const x = (sx - w / 2) / scale + xC;
      const y = (h / 2 - sy) / scale + yC;
      return { x, y };
    };

    let drawPending = false;
    const requestDraw = () => {
      if (drawPending) return;
      drawPending = true;
      requestAnimationFrame(() => {
        drawPending = false;
        draw();
      });
    };

    const resize = () => {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const cssW = Math.max(10, rect.width);
      const cssH = Math.max(10, rect.height);
      canvas.width = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      requestDraw();
    };

    let components = [];
    let vCount = 0;
    let lCount = 0;
    let compSeq = 1;
    const newId = () => `c_${compSeq++}`;

    const palette = [
      '#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd',
      '#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf',
      '#0f4c81','#a23b72','#1b9e77','#d95f02','#7570b3'
    ];
    let colorIndex = 0;
    const nextColor = () => palette[(colorIndex++) % palette.length];

    const ensureDomain = (c) => {
      if (c.domain.xMax - c.domain.xMin < EPS){
        const mid = (c.domain.xMin + c.domain.xMax) / 2;
        c.domain.xMin = mid - EPS/2;
        c.domain.xMax = mid + EPS/2;
      }
      const width = c.domain.xMax - c.domain.xMin;
      if (c.domain.xMin < DOMAIN_MIN){
        c.domain.xMin = DOMAIN_MIN;
        c.domain.xMax = DOMAIN_MIN + width;
      }
      if (c.domain.xMax > DOMAIN_MAX){
        c.domain.xMax = DOMAIN_MAX;
        c.domain.xMin = DOMAIN_MAX - width;
      }
      if (c.domain.xMax - c.domain.xMin < EPS){
        c.domain.xMax = c.domain.xMin + EPS;
      }
    };

    const defaultComponent = (type) => {
      if (type === TYPE_V){
        vCount++;
        const c = {
          id: newId(),
          type: TYPE_V,
          name: `V${vCount}`,
          visible: true,
          color: nextColor(),
          a: 0,
          showAxis: false,
          domain: { xMin: -6, xMax: 6 }
        };
        ensureDomain(c);
        return c;
      }
      lCount++;
      const c = {
        id: newId(),
        type: TYPE_L,
        name: `L${lCount}`,
        visible: true,
        color: nextColor(),
        k: 1,
        b: 0,
        showIntercepts: false,
        domain: { xMin: -6, xMax: 6 }
      };
      ensureDomain(c);
      return c;
    };

    const evalY = (c, x) => (c.type === TYPE_V) ? Math.abs(x + c.a) : (c.k * x + c.b);

    const getExpressionText = (c) => {
      ensureDomain(c);
      if (c.type === TYPE_V){
        const part = c.a >= 0 ? `x+${formatNum(c.a)}` : `x${formatNum(c.a)}`;
        return `y = |${part}|，定义域：x∈[${formatNum(c.domain.xMin)}, ${formatNum(c.domain.xMax)}]`;
      } else {
        const bStr = c.b >= 0 ? `+${formatNum(c.b)}` : `${formatNum(c.b)}`;
        return `y = (${formatNum(c.k)})x${bStr}，定义域：x∈[${formatNum(c.domain.xMin)}, ${formatNum(c.domain.xMax)}]`;
      }
    };

    const gridToggle = document.getElementById('a2GridToggle');
    const resetViewBtn = document.getElementById('a2ResetViewBtn');
    const clearAllBtn = document.getElementById('a2ClearAllBtn');
    const addVBtn = document.getElementById('a2AddVBtn');
    const addLBtn = document.getElementById('a2AddLBtn');

    const cardsEl = document.getElementById('a2Cards');
    const emptyTipEl = document.getElementById('a2EmptyTip');
    const statusV = document.getElementById('a2StatusV');
    const statusL = document.getElementById('a2StatusL');

    const uiMap = new Map();

    const updateEmptyTip = () => {
      emptyTipEl.style.display = components.length === 0 ? 'block' : 'none';
    };

    const updateStatuses = () => {
      const hasV = components.some(c => c.type === TYPE_V);
      const hasL = components.some(c => c.type === TYPE_L);

      statusV.className = 'badge ' + (hasV ? 'ok' : 'warn');
      statusV.textContent = (hasV ? '✅' : '⚠️') + ' 至少 1 条 V';

      statusL.className = 'badge ' + (hasL ? 'ok' : 'warn');
      statusL.textContent = (hasL ? '✅' : '⚠️') + ' 至少 1 条直线';
    };

    const makeRangeRow = ({labelText, min, max, step, getVal, setVal, onUpdateText}) => {
      const row = document.createElement('div');
      row.className = 'row';

      const label = document.createElement('label');
      label.textContent = `${labelText}：`;

      const ctrl = document.createElement('div');
      ctrl.className = 'ctrl';

      const range = document.createElement('input');
      range.type = 'range';
      range.min = min;
      range.max = max;
      range.step = step;

      const num = document.createElement('input');
      num.type = 'number';
      num.step = step;
      num.min = min;
      num.max = max;
      num.style.maxWidth = '110px';

      const valSpan = document.createElement('span');
      valSpan.className = 'val';

      const syncUI = (v) => {
        range.value = v;
        num.value = v;
        valSpan.textContent = formatNum(v);
      };

      const commit = (v) => {
        if (Number.isNaN(v)) return;
        const vv = clamp(v, min, max);
        setVal(vv);
        syncUI(vv);
        onUpdateText?.();
        requestDraw();
      };

      syncUI(getVal());
      range.addEventListener('input', () => commit(parseFloat(range.value)));
      num.addEventListener('change', () => commit(parseFloat(num.value)));

      ctrl.appendChild(range);
      ctrl.appendChild(num);
      row.appendChild(label);
      row.appendChild(ctrl);
      row.appendChild(valSpan);

      return { row, syncUI };
    };

    const makeDomainField = ({labelText, min, max, step, getVal, setVal, afterCommit}) => {
      const field = document.createElement('div');
      field.className = 'field';

      const lab = document.createElement('label');
      lab.textContent = labelText;
      field.appendChild(lab);

      const pair = document.createElement('div');
      pair.className = 'pair';

      const range = document.createElement('input');
      range.type = 'range';
      range.min = min;
      range.max = max;
      range.step = step;

      const num = document.createElement('input');
      num.type = 'number';
      num.step = step;
      num.min = min;
      num.max = max;

      const syncUI = (v) => {
        range.value = v;
        num.value = v;
      };

      const commit = (v) => {
        if (Number.isNaN(v)) return;
        const vv = clamp(v, min, max);
        setVal(vv);
        afterCommit?.();
        syncUI(getVal());
        requestDraw();
      };

      syncUI(getVal());
      range.addEventListener('input', () => commit(parseFloat(range.value)));
      num.addEventListener('change', () => commit(parseFloat(num.value)));

      pair.appendChild(range);
      pair.appendChild(num);
      field.appendChild(pair);

      return { field, syncUI };
    };

    const buildCard = (c) => {
      const card = document.createElement('div');
      card.className = 'card';
      card.dataset.id = c.id;

      const head = document.createElement('div');
      head.className = 'cardHeader';

      const left = document.createElement('div');
      const title = document.createElement('div');
      title.className = 'cardTitle';

      const dot = document.createElement('span');
      dot.className = 'colorDot';
      dot.style.background = c.color;

      const typeTitle = c.type === TYPE_V ? `${c.name}：y=|x+a|` : `${c.name}：y=kx+b`;
      title.appendChild(dot);
      title.appendChild(document.createTextNode(typeTitle));

      const expr = document.createElement('div');
      expr.className = 'expr';
      expr.textContent = getExpressionText(c);

      left.appendChild(title);
      left.appendChild(expr);

      const ops = document.createElement('div');
      ops.className = 'cardOps';

      const visBtn = document.createElement('button');
      visBtn.className = 'miniBtn primary';
      visBtn.textContent = c.visible ? '隐藏' : '显示';
      visBtn.addEventListener('click', () => {
        c.visible = !c.visible;
        visBtn.textContent = c.visible ? '隐藏' : '显示';
        requestDraw();
      });

      const delBtn = document.createElement('button');
      delBtn.className = 'miniBtn danger';
      delBtn.textContent = '删除';
      delBtn.addEventListener('click', () => {
        components = components.filter(x => x.id !== c.id);
        uiMap.delete(c.id);
        card.remove();
        updateEmptyTip();
        updateStatuses();
        requestDraw();
      });

      ops.appendChild(visBtn);
      ops.appendChild(delBtn);

      head.appendChild(left);
      head.appendChild(ops);
      card.appendChild(head);

      const updateExpr = () => { expr.textContent = getExpressionText(c); };

      let syncA=null, syncK=null, syncB=null, syncXMin=null, syncXMax=null;

      if (c.type === TYPE_V){
        const aRow = makeRangeRow({
          labelText: 'a',
          min: -10, max: 10, step: 0.5,
          getVal: () => c.a,
          setVal: (v) => { c.a = v; },
          onUpdateText: updateExpr
        });
        card.appendChild(aRow.row);
        syncA = (v) => { aRow.syncUI(v); updateExpr(); };

        const row = document.createElement('div');
        row.className = 'row';
        const lab = document.createElement('label');
        lab.textContent = '辅助：';
        const ctrl = document.createElement('div');
        ctrl.className = 'ctrl';

        const ck = document.createElement('input');
        ck.type = 'checkbox';
        ck.checked = !!c.showAxis;
        ck.addEventListener('change', () => {
          c.showAxis = ck.checked;
          requestDraw();
        });

        const span = document.createElement('span');
        span.className = 'small';
        span.textContent = '显示对称轴 x=-a（竖直虚线）';

        ctrl.appendChild(ck);
        ctrl.appendChild(span);
        row.appendChild(lab);
        row.appendChild(ctrl);
        card.appendChild(row);

      } else {
        const kRow = makeRangeRow({
          labelText: 'k',
          min: -5, max: 5, step: 0.1,
          getVal: () => c.k,
          setVal: (v) => { c.k = v; },
          onUpdateText: updateExpr
        });
        card.appendChild(kRow.row);
        syncK = (v) => { kRow.syncUI(v); updateExpr(); };

        const bRow = makeRangeRow({
          labelText: 'b',
          min: -10, max: 10, step: 0.5,
          getVal: () => c.b,
          setVal: (v) => { c.b = v; },
          onUpdateText: updateExpr
        });
        card.appendChild(bRow.row);
        syncB = (v) => { bRow.syncUI(v); updateExpr(); };

        const row = document.createElement('div');
        row.className = 'row';
        const lab = document.createElement('label');
        lab.textContent = '可选：';
        const ctrl = document.createElement('div');
        ctrl.className = 'ctrl';

        const ck = document.createElement('input');
        ck.type = 'checkbox';
        ck.checked = !!c.showIntercepts;
        ck.addEventListener('change', () => {
          c.showIntercepts = ck.checked;
          requestDraw();
        });

        const span = document.createElement('span');
        span.className = 'small';
        span.textContent = '显示与坐标轴交点（可选）';

        ctrl.appendChild(ck);
        ctrl.appendChild(span);
        row.appendChild(lab);
        row.appendChild(ctrl);
        card.appendChild(row);
      }

      const domTitle = document.createElement('div');
      domTitle.className = 'row';
      domTitle.innerHTML = `<label>定义域裁剪</label><span class="val small">可在画布拖动端点调整</span>`;
      card.appendChild(domTitle);

      const domGrid = document.createElement('div');
      domGrid.className = 'domainGrid';

      const afterDomainCommit = () => {
        ensureDomain(c);
        updateExpr();
      };

      const xMinField = makeDomainField({
        labelText: 'x_min',
        min: DOMAIN_MIN, max: DOMAIN_MAX, step: 0.5,
        getVal: () => c.domain.xMin,
        setVal: (v) => { c.domain.xMin = v; },
        afterCommit: afterDomainCommit
      });
      const xMaxField = makeDomainField({
        labelText: 'x_max',
        min: DOMAIN_MIN, max: DOMAIN_MAX, step: 0.5,
        getVal: () => c.domain.xMax,
        setVal: (v) => { c.domain.xMax = v; },
        afterCommit: afterDomainCommit
      });

      domGrid.appendChild(xMinField.field);
      domGrid.appendChild(xMaxField.field);
      card.appendChild(domGrid);

      syncXMin = (v) => { c.domain.xMin = v; ensureDomain(c); xMinField.syncUI(c.domain.xMin); updateExpr(); };
      syncXMax = (v) => { c.domain.xMax = v; ensureDomain(c); xMaxField.syncUI(c.domain.xMax); updateExpr(); };

      uiMap.set(c.id, { visBtn, syncA, syncK, syncB, syncXMin, syncXMax, updateExpr });

      return card;
    };

    const fullRenderCards = () => {
      cardsEl.innerHTML = '';
      uiMap.clear();
      components.forEach(c => cardsEl.appendChild(buildCard(c)));
      updateEmptyTip();
      updateStatuses();
    };

    const chooseNiceStep = (raw) => {
      const pow = Math.pow(10, Math.floor(Math.log10(raw)));
      const n = raw / pow;
      if (n < 1.5) return 1 * pow;
      if (n < 3.5) return 2 * pow;
      if (n < 7.5) return 5 * pow;
      return 10 * pow;
    };

    const drawGrid = () => {
      const { w, h, scale, xC, yC } = getTransform();
      const xHalf = (w/2) / scale;
      const yHalf = (h/2) / scale;
      const xVisMin = xC - xHalf, xVisMax = xC + xHalf;
      const yVisMin = yC - yHalf, yVisMax = yC + yHalf;

      ctx.save();
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim() || '#e6e6e6';
      ctx.lineWidth = 1;

      const step = chooseNiceStep(Math.max(view.xMax - view.xMin, view.yMax - view.yMin) / 12);

      for (let x = Math.ceil(xVisMin / step) * step; x <= xVisMax + 1e-9; x += step){
        const p1 = worldToScreen(x, yVisMin);
        const p2 = worldToScreen(x, yVisMax);
        ctx.beginPath();
        ctx.moveTo(p1.sx, p1.sy);
        ctx.lineTo(p2.sx, p2.sy);
        ctx.stroke();
      }
      for (let y = Math.ceil(yVisMin / step) * step; y <= yVisMax + 1e-9; y += step){
        const p1 = worldToScreen(xVisMin, y);
        const p2 = worldToScreen(xVisMax, y);
        ctx.beginPath();
        ctx.moveTo(p1.sx, p1.sy);
        ctx.lineTo(p2.sx, p2.sy);
        ctx.stroke();
      }
      ctx.restore();
    };

    const drawAxes = () => {
      const { w, h, scale, xC, yC } = getTransform();
      const xHalf = (w/2) / scale;
      const yHalf = (h/2) / scale;
      const xVisMin = xC - xHalf, xVisMax = xC + xHalf;
      const yVisMin = yC - yHalf, yVisMax = yC + yHalf;

      ctx.save();
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--axis').trim() || '#000';
      ctx.fillStyle = ctx.strokeStyle;
      ctx.lineWidth = 2;

      if (yVisMin <= 0 && yVisMax >= 0){
        const p1 = worldToScreen(xVisMin, 0);
        const p2 = worldToScreen(xVisMax, 0);
        ctx.beginPath();
        ctx.moveTo(p1.sx, p1.sy);
        ctx.lineTo(p2.sx, p2.sy);
        ctx.stroke();
      }

      if (xVisMin <= 0 && xVisMax >= 0){
        const p1 = worldToScreen(0, yVisMin);
        const p2 = worldToScreen(0, yVisMax);
        ctx.beginPath();
        ctx.moveTo(p1.sx, p1.sy);
        ctx.lineTo(p2.sx, p2.sy);
        ctx.stroke();
      }

      ctx.font = '13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Arial';
      ctx.textBaseline = 'middle';

      if (xVisMin <= 0 && xVisMax >= 0 && yVisMin <= 0 && yVisMax >= 0){
        const o = worldToScreen(0, 0);
        ctx.fillText('O', o.sx + 6, o.sy + 12);
      }

      if (yVisMin <= 0 && yVisMax >= 0){
        const p = worldToScreen(xVisMax, 0);
        ctx.fillText('x', p.sx - 14, p.sy + 18);
      }

      if (xVisMin <= 0 && xVisMax >= 0){
        const p = worldToScreen(0, yVisMax);
        ctx.fillText('y', p.sx + 12, p.sy + 10);
      }

      ctx.restore();
    };

    const drawSymAxis = (c) => {
      const x0 = -c.a;
      const { w, h, scale, xC, yC } = getTransform();
      const xHalf = (w/2) / scale;
      const yHalf = (h/2) / scale;
      const xVisMin = xC - xHalf, xVisMax = xC + xHalf;
      const yVisMin = yC - yHalf, yVisMax = yC + yHalf;
      if (x0 < xVisMin || x0 > xVisMax) return;

      const p1 = worldToScreen(x0, yVisMin);
      const p2 = worldToScreen(x0, yVisMax);

      ctx.save();
      ctx.strokeStyle = hexToRgba(c.color, 0.45);
      ctx.lineWidth = 1.5;
      ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.moveTo(p1.sx, p1.sy);
      ctx.lineTo(p2.sx, p2.sy);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    };

    const drawPoint = (sx, sy, r, fill, stroke) => {
      ctx.save();
      ctx.fillStyle = fill;
      ctx.strokeStyle = stroke || 'rgba(0,0,0,.35)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(sx, sy, r, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    };

    const drawIntercepts = (c) => {
      ctx.save();
      ctx.fillStyle = c.color;
      ctx.strokeStyle = c.color;
      ctx.lineWidth = 1.5;
      ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Arial';
      ctx.textBaseline = 'middle';

      const pY = worldToScreen(0, c.b);
      drawPoint(pY.sx, pY.sy, 4, c.color, c.color);
      ctx.fillText(`(0, ${formatNum(c.b)})`, pY.sx + 8, pY.sy);

      if (Math.abs(c.k) > 1e-12){
        const x = -c.b / c.k;
        if (x >= c.domain.xMin - 1e-9 && x <= c.domain.xMax + 1e-9){
          const pX = worldToScreen(x, 0);
          drawPoint(pX.sx, pX.sy, 4, c.color, c.color);
          ctx.fillText(`(${formatNum(x)}, 0)`, pX.sx + 8, pX.sy);
        }
      }
      ctx.restore();
    };

    const drawComponentCurve = (c, isActive) => {
      ensureDomain(c);
      const xMin = c.domain.xMin;
      const xMax = c.domain.xMax;

      const samples = 600;
      const dx = (xMax - xMin) / samples;

      ctx.save();
      ctx.strokeStyle = c.color;
      ctx.lineWidth = isActive ? 3 : 2;
      ctx.beginPath();

      for (let i=0; i<=samples; i++){
        const x = xMin + dx * i;
        const y = evalY(c, x);
        const p = worldToScreen(x, y);
        if (i === 0) ctx.moveTo(p.sx, p.sy);
        else ctx.lineTo(p.sx, p.sy);
      }
      ctx.stroke();
      ctx.restore();

      const yL = evalY(c, xMin);
      const yR = evalY(c, xMax);
      const pL = worldToScreen(xMin, yL);
      const pR = worldToScreen(xMax, yR);

      const r = isActive ? 6 : 5;
      drawPoint(pL.sx, pL.sy, r, '#fff', c.color);
      drawPoint(pR.sx, pR.sy, r, '#fff', c.color);
    };

    let activeId = null;
    let drag = null;

    const pxDist = (x1,y1,x2,y2) => Math.hypot(x1-x2, y1-y2);

    const hitTestHandle = (c, mouseSx, mouseSy) => {
      ensureDomain(c);
      const xMin = c.domain.xMin, xMax = c.domain.xMax;
      const pL = worldToScreen(xMin, evalY(c, xMin));
      const pR = worldToScreen(xMax, evalY(c, xMax));
      const dL = pxDist(mouseSx, mouseSy, pL.sx, pL.sy);
      const dR = pxDist(mouseSx, mouseSy, pR.sx, pR.sy);
      const thr = 10;
      if (dL <= thr) return { which: 'min', dist: dL };
      if (dR <= thr) return { which: 'max', dist: dR };
      return null;
    };

    const hitTestCurve = (c, mouseSx, mouseSy) => {
      const mw = screenToWorld(mouseSx, mouseSy);
      const x = mw.x;
      ensureDomain(c);
      if (x < c.domain.xMin || x > c.domain.xMax) return null;

      const y = evalY(c, x);
      const p = worldToScreen(x, y);
      const d = Math.abs(p.sy - mouseSy);
      const thr = 8;
      if (d <= thr) return { dist: d };
      return null;
    };

    const bringToFront = (id) => {
      const idx = components.findIndex(c => c.id === id);
      if (idx >= 0 && idx !== components.length - 1){
        const [c] = components.splice(idx, 1);
        components.push(c);
      }
    };

    const setActive = (id) => {
      activeId = id;
      bringToFront(id);
      requestDraw();
    };

    const syncUIFromModel = (c) => {
      const ui = uiMap.get(c.id);
      if (!ui) return;
      ui.updateExpr?.();
      if (c.type === TYPE_V && ui.syncA) ui.syncA(c.a);
      if (c.type === TYPE_L){
        if (ui.syncK) ui.syncK(c.k);
        if (ui.syncB) ui.syncB(c.b);
      }
      if (ui.syncXMin) ui.syncXMin(c.domain.xMin);
      if (ui.syncXMax) ui.syncXMax(c.domain.xMax);
      if (ui.visBtn) ui.visBtn.textContent = c.visible ? '隐藏' : '显示';
    };

    const startDrag = (e) => {
      const rect = canvas.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;

      for (let i = components.length - 1; i >= 0; i--){
        const c = components[i];
        if (!c.visible) continue;

        const hh = hitTestHandle(c, sx, sy);
        if (hh){
          setActive(c.id);
          drag = { mode: 'handle', id: c.id, which: hh.which };
          canvas.setPointerCapture(e.pointerId);
          return;
        }

        const hc = hitTestCurve(c, sx, sy);
        if (hc){
          setActive(c.id);
          const startW = screenToWorld(sx, sy);
          drag = {
            mode: 'curve',
            id: c.id,
            startW,
            startDomain: { xMin: c.domain.xMin, xMax: c.domain.xMax },
            startParams: c.type === TYPE_V ? { a: c.a } : { k: c.k, b: c.b }
          };
          canvas.setPointerCapture(e.pointerId);
          return;
        }
      }

      activeId = null;
      requestDraw();
    };

    const moveDrag = (e) => {
      if (!drag) return;

      const c = components.find(x => x.id === drag.id);
      if (!c) return;

      const rect = canvas.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;
      const curW = screenToWorld(sx, sy);

      if (drag.mode === 'handle'){
        let x = snap(curW.x);
        x = clamp(x, DOMAIN_MIN, DOMAIN_MAX);

        if (drag.which === 'min') c.domain.xMin = x;
        else c.domain.xMax = x;

        if (c.domain.xMin > c.domain.xMax){
          const tmp = c.domain.xMin;
          c.domain.xMin = c.domain.xMax;
          c.domain.xMax = tmp;
          drag.which = (drag.which === 'min') ? 'max' : 'min';
        }

        if (c.domain.xMax - c.domain.xMin < EPS){
          if (drag.which === 'min') c.domain.xMin = c.domain.xMax - EPS;
          else c.domain.xMax = c.domain.xMin + EPS;
        }

        ensureDomain(c);
        syncUIFromModel(c);
        requestDraw();
        return;
      }

      if (drag.mode === 'curve'){
        const dx = snap(curW.x - drag.startW.x);
        const dy = snap(curW.y - drag.startW.y);

        const width = drag.startDomain.xMax - drag.startDomain.xMin;
        let newMin = drag.startDomain.xMin + dx;
        let newMax = drag.startDomain.xMax + dx;

        if (newMin < DOMAIN_MIN){ newMin = DOMAIN_MIN; newMax = DOMAIN_MIN + width; }
        if (newMax > DOMAIN_MAX){ newMax = DOMAIN_MAX; newMin = DOMAIN_MAX - width; }

        c.domain.xMin = newMin;
        c.domain.xMax = newMax;

        if (c.type === TYPE_V){
          c.a = clamp(drag.startParams.a - dx, -10, 10);
        } else {
          const k = c.k;
          c.b = clamp(drag.startParams.b + dy - k * dx, -10, 10);
        }

        ensureDomain(c);
        syncUIFromModel(c);
        requestDraw();
      }
    };

    const endDrag = (e) => {
      if (!drag) return;
      drag = null;
      try{ canvas.releasePointerCapture(e.pointerId); }catch(_){}
    };

    const updateCursor = (e) => {
      if (drag) return;
      const rect = canvas.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;

      for (let i = components.length - 1; i >= 0; i--){
        const c = components[i];
        if (!c.visible) continue;
        const hh = hitTestHandle(c, sx, sy);
        if (hh){ canvas.style.cursor = 'ew-resize'; return; }
        const hc = hitTestCurve(c, sx, sy);
        if (hc){ canvas.style.cursor = (c.type === TYPE_V) ? 'ew-resize' : 'move'; return; }
      }
      canvas.style.cursor = 'default';
    };

    canvas.addEventListener('pointerdown', startDrag);
    canvas.addEventListener('pointermove', (e) => { updateCursor(e); moveDrag(e); });
    canvas.addEventListener('pointerup', endDrag);
    canvas.addEventListener('pointercancel', endDrag);
    canvas.addEventListener('pointerleave', () => { if (!drag) canvas.style.cursor = 'default'; });

    const drawMainGrid = drawGrid;
    const drawMainAxes = drawAxes;

    function draw(){
      const { w, h } = getTransform();
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0,0,w,h);

      if (gridToggle.checked) drawMainGrid();
      if (showAxes) drawMainAxes();

      const act = activeId ? components.find(c => c.id === activeId) : null;

      components.forEach(c => {
        if (!c.visible) return;
        if (act && c.id === act.id) return;
        if (c.type === TYPE_V && c.showAxis) drawSymAxis(c);
        drawComponentCurve(c, false);
        if (c.type === TYPE_L && c.showIntercepts) drawIntercepts(c);
      });

      if (act && act.visible){
        if (act.type === TYPE_V && act.showAxis) drawSymAxis(act);
        drawComponentCurve(act, true);
        if (act.type === TYPE_L && act.showIntercepts) drawIntercepts(act);
      }
    }

    addVBtn.addEventListener('click', () => {
      const c = defaultComponent(TYPE_V);
      components.push(c);
      cardsEl.appendChild(buildCard(c));
      updateEmptyTip();
      updateStatuses();
      setActive(c.id);
      requestDraw();
    });

    addLBtn.addEventListener('click', () => {
      const c = defaultComponent(TYPE_L);
      components.push(c);
      cardsEl.appendChild(buildCard(c));
      updateEmptyTip();
      updateStatuses();
      setActive(c.id);
      requestDraw();
    });

    clearAllBtn.addEventListener('click', () => {
      components = [];
      vCount = 0;
      lCount = 0;
      colorIndex = 0;
      compSeq = 1;
      activeId = null;
      fullRenderCards();
      requestDraw();
    });

    resetViewBtn.addEventListener('click', () => {
      view = { ...viewDefault };
      setViewText();
      requestDraw();
    });

    gridToggle.addEventListener('change', () => requestDraw());

    toggleAxesBtn.addEventListener('click', () => {
      showAxes = !showAxes;
      toggleAxesBtn.textContent = showAxes ? '隐藏坐标系' : '显示坐标系';
      requestDraw();
    });

    const ro = new ResizeObserver(() => resize());
    ro.observe(canvas);
    window.addEventListener('resize', resize);

    setViewText();
    fullRenderCards();
    requestAnimationFrame(() => resize());

    return { resize, draw: requestDraw };
  }

  a1Api = initActivity1();
  a2Api = initActivity2();

  setActiveTab(1);
});
</script>
</body>
</html>
